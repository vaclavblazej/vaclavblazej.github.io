<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Homepage of Vašek</title>
    <link>https://vaclavblazej.github.io/tags/algorithm/</link>
    <description>Recent content in Algorithm on Homepage of Vašek</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>blazeva1 -a- fit.cvut.cz &lt;Václav Blažej&gt; (Václav Blažej)</managingEditor>
    <webMaster>blazeva1 -a- fit.cvut.cz &lt;Václav Blažej&gt; (Václav Blažej)</webMaster>
    <copyright>© Václav Blažej</copyright>
    <lastBuildDate>Wed, 19 Aug 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://vaclavblazej.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fast Fourier Transform (FFT) c&#43;&#43; code explained</title>
      <link>https://vaclavblazej.github.io/post/2020/fft/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><author>blazeva1 -a- fit.cvut.cz &lt;Václav Blažej&gt; (Václav Blažej)</author>
      <guid>https://vaclavblazej.github.io/post/2020/fft/</guid>
      <description>Discrete Fourier Transform (DFT) takes $x_0,\dots,x_{N-1}$ and produces $X_0,\dots,X_{N-1}$ by the following equality&#xA;$$X_k = \sum^{N-1}_{n=0} x_n e^{-i2\pi kn/N}.$$&#xA;Fast Fourier Transform (FFT) does this computation effectively in $O(N \log N)$ time. Possibility of doing the computation in a more effective way raises from decomposition of the values into odd and even elements, and applying the computation recursively.&#xA;Let $\omega_N=e^{-2i\pi /N}$, so we have&#xA;$$ X_k = \sum^{N-1}{n=0} x_n \omega^{nk}N = \sum^{N/2-1}{n=0} x{2n} \omega^{2nk}_N</description>
    </item>
    <item>
      <title>Násobení polynomů</title>
      <link>https://vaclavblazej.github.io/post/2015/polymul/</link>
      <pubDate>Sun, 29 Nov 2015 00:00:00 +0000</pubDate><author>blazeva1 -a- fit.cvut.cz &lt;Václav Blažej&gt; (Václav Blažej)</author>
      <guid>https://vaclavblazej.github.io/post/2015/polymul/</guid>
      <description>Násobení dvou polynomů se dá naprogramovat třemi základními způsoby, které jsou progresivně obtížné na pochopení. Zde najdete přehled známých řešení, jejich naměřenou rychlost a celkové srovnání.&#xA;Naivní řešení Násobení můžeme implementovat přesně podle definice. Je to nejspolehlivější způsob, který ale není zrovna efektivní. Výsledná složitost je pro velikost N obou polynomů O(N^2). Výsledný graf měření odpovídá očekávání - není co dodat.&#xA;Karatsuba Algoritmus Karatsuba využívá toho, že pro výpočet (Ax + B)(C*x + D) nemusíme dělat čtyři násobení, ale pouze tři.</description>
    </item>
  </channel>
</rss>
