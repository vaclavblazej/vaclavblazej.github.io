<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>
        
            PPA - Pokročilé Paralelní Algoritmy - Homepage of Vašek
        
    </title>
    <meta name="description" content="Homepage of Vašek">
    <meta name="author" content="">

    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <link href="https://vaclavblazej.github.io//font/fonts.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://vaclavblazej.github.io/css/fonts.css">

    
    <script src="https://vaclavblazej.github.io/js/custom.js"></script>
    <link rel="stylesheet" href="https://vaclavblazej.github.io/css/custom.css">

    <link rel="shortcut icon" href="https://vaclavblazej.github.io//favicon.ico" />

    

    
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [ ['$','$'] ],
                displayMath: [ ["\\[","\\]"] ],
                processEscapes: true,
                autoload: {
                    color: [],
                    colorv2: ['color']
                },
                packages: {'[+]': ['noerrors']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process',
                renderActions: {
                    addMenu: [0, '', '']
                }
            },
            loader: {
                load: ['[tex]/noerrors']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>

    <script src="https://vaclavblazej.github.io/js/jquery.min.js" type="text/javascript"></script>

</head>
<body>

<div class="header noprint">
    
    <div class="desktop nav-menu">
        <a href="https://vaclavblazej.github.io/" class="site-title pad">Homepage of Vašek</a>
        <ul>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/">Material</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/post/">Blog</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/pub/">Research</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="mobile nav-menu">
        <a href="https://vaclavblazej.github.io/" class="site-title pad">Homepage of Vašek</a>
        <a href="#" id="toggle-btn">&#9776;</a>
    </div>
    <div>
        <ul id="toggle-content" style="display:none;">
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/">Material</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/post/">Blog</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/pub/">Research</a>
            </li>
            
            <li class="pad-vertically">
                <a class="pad" href="https://vaclavblazej.github.io/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>



<div class="content">
    
    <div class="post">
        <div class="post-title">
            <p class="footnote">
                


    <time datetime="2018-06-11T00:00:00Z" class="post-list timeago">11.06.2018</time>






    |



    tags:[ <a href="https://vaclavblazej.github.io/tags/school">school</a> ]






            </p>
            <h1>PPA - Pokročilé Paralelní Algoritmy</h1>

            

        </div>
        <div class="post-content">
            <h1 id="základy">Základy</h1>
<h2 id="sekvenční">Sekvenční</h2>
<ul>
<li>T(n) - doba běhu algoritmu pro vstup velikosti n</li>
<li>SL(n) - sequential lower bound - dolní mez doby běhu sekvenčního algoritmu</li>
<li>SU(n) - sequential upper bound - horní mez; worst case nejlepšího známého algoritmu</li>
</ul>
<h2 id="paralelní">Paralelní</h2>
<ul>
<li>T(n,p) - doba běhu algoritmu pro vstup velikosti n na p procesorech</li>
<li>S(n,p)=SU(n)/T(n,p) - zrychlení oproti sekvenčnímu řešení; lineární zrychlení je, pokud S(n,p)=\Theta(p)</li>
<li>L(n,p)=SL(n)/p - lower bound</li>
<li>C(n,p)=p T(n,p) - cena; algo je cenově optimální, pokud C(n,p)=O(SU(n))</li>
<li>W(n,p) - paralelní práce je u synchroních algoritmů součet počtu taktů přes všechny procesory, a u asynchroních algoritmů součet času práce vláken; algo je pracovně optimální, pokud W(n,p)=O(SU(n))</li>
<li>E(n,p)=SU(n)/C(n,p) - paralelní efektivita / zrychlení na procesor</li>
</ul>
<p>Algoritmus je cenově optimální &lt;=&gt; má lineární zrychlení &lt;=&gt; má konstantní efektivitu</p>
<h2 id="isoefektivní-funkce">Isoefektivní funkce</h2>
<p>Cenová škálovatelnost &hellip; tj. chceme aby algoritmus byl efektivní.
Mějme p jader, jaký je minimální velikost vstupu, aby byl výpočet efektivní?
A naopak, mějme vstup velikosti n, jaký je nejvyšší počet jader p, aby byl výpočet efektivní?</p>
<ul>
<li>$\psi_1$(p)=n - minimální velikost vstupu, aby byl výpočet efektivní</li>
<li>$\psi_2$(n)=p - maximální počet jader, aby byl výpočet efektivní</li>
</ul>
<p>Pak je</p>
<ul>
<li>$\psi_3$(n)=p - minimální počet jader takový, aby byl čas výpočtu byl minimální možný</li>
</ul>
<p>Amdalův zákon - mějme část programu fp, která lze paralelizovat, a část fs, která nejde paralelizovat, potom T(n,p)&gt;=fs+fp/p, S(n,p)&lt;=1/(fs+(1-fs)/p)</p>
<hr>
<h1 id="paralelní-prefixový-součet-pps">Paralelní prefixový součet (PPS)</h1>
<p>Pro asociativní operaci + chceme prefixový součet.</p>
<pre><code>In:  2  4  5  3  2  5  7  6  1  4
Out: 2  6 11 14 16 21 28 34 35 39
</code></pre>
<p>Lze na EREW-PRAM(n,n) pomocí sčítání ze vzdálenosti 2^i v O(log n)</p>
<ul>
<li>T(n,p)=O(n/p+log p)</li>
<li>C(n,p)=O(n+log p)</li>
<li>E(n,p)=O(n/(n+p log p))</li>
</ul>
<p>Použití v RadixSortu, Paralelní sčítačka.</p>
<h1 id="tridiagonální-systém-rovnic">Tridiagonální systém rovnic</h1>
<p>Mějme systém rovnic v následujícím tvaru:</p>
<pre tabindex="0"><code>|g1 h1  0  0  0 | |x1|   |b1|
|f2 g2 h2  0  0 | |x2|   |b2|
| 0 f3 g3 h3  0 | |x3| = |b3|
| 0  0 f4 g4 h4 | |x4|   |b4|
| 0  0  0 f5 g5 | |x5|   |b5|
</code></pre><p>Upravíme rovnice do následujícího tvaru:</p>
<pre tabindex="0"><code>|x(i+1)|   |-gi/hi -fi/hi bi/hi| |  xi  |
|  xi  | = |   1      0     0  | |x(i-1)|
|   1  |   |   0      0     1  | |   1  |
</code></pre><p>zjevně pro Hi=Gi G(i-1) &hellip; G1</p>
<pre tabindex="0"><code>|x(i+1)|      |  x1  |
|  xi  | = Hi |   0  |
|   1  |      |   1  |
</code></pre><p>Použijeme PPS pro spočtení Hi O(n/p + log p) a poslední procesor vyřeší svojí rovnici o neznámých x1, xn-1 a xn O(1).
Výsledek rozešle všem O(log p), ti pak dopočítají svoje proměnné O(n/p).</p>
<p>Celková složitost je O(n/p + log p).</p>
<h1 id="segmentový-paralelní-prefixový-součet-spps">Segmentový paralelní prefixový součet (SPPS)</h1>
<p>Výpočet prefixového součtu uvnitř segmentů.</p>
<pre tabindex="0"><code>In:  |2  4  5 |3  2  5 |7  6  1  4
Out: |2  6 11 |3  5 10 |7 13 14 18
</code></pre><p>Je PPS s modifikovanou operací +&rsquo;. Pozorujeme, že zůstává asociativní.</p>
<pre tabindex="0"><code> +&#39;    b    |b   
 a    a+b   |b
|a  |(a+b)  |b
</code></pre><h1 id="sken--rekurence">Sken &amp; rekurence</h1>
<p>Rekurence řádu m je množina rovnic xi=f(x(i-1), &hellip;, x(i-m)) a výchozích hodnot x0, &hellip;, x(m-1).
Sken je jednoduchá rekurence 1. řádu, tj. xi=x(i-1) (+) bi / x0=b0.</p>
<h2 id="lineární-rekurence-prvního-řádu">Lineární rekurence prvního řádu</h2>
<p>Mějme předpis x0=b0; xi=(x(i-1) (x) ai) (+) bi, kde chceme, aby operace (+) byla asociativní, a (x) semi-asociativní (tedy existujea asociativní operace (.) taková, že (a (x) b) (x) c = a (x) (b (.) c) ), a (x) je distributivní vůči (+).</p>
<p>Úlohu přetransformujeme, a budeme pracovat s páry hodnot.
Definujme y0=a0; yi=y(i-1) (.) ai; ci=[ai,bi]; si=[yi,xi].
Potom s0=[y0,x0]=[a0,b0]=c0 a si=[yi,xi]=[y(i-1) (.) ai,(x(i-1) (x) ai) (+) bi] = [y(i-1),x(i-1)] (o) [ai,bi] = s(i-1) (o) ci, kde (o) je operace definovaná jako: [a,b] (o) [c,d] = [a (.) c, (b (x) c) (+) d] a není obtížné ukázat, že je tato operace asociativní.</p>
<p>Nyní lze použít sken pro spočtení hodnot.
Čas bude 2(T(+)+T(x)+T(.))(n/p+log p).</p>
<p>Podobně lze sestavit rekurence m-tého řády, kde se počítá s m-prvkovými</p>
<h2 id="polynomiální-interpolace">Polynomiální interpolace</h2>
<p>Mějme funkci f(x) definovanou n+1 body [x,f(x)], a &lt;= x1 &lt;= x2 &lt;= &hellip; &lt;= b.
Cílem je najít polynom p(xi)=f(xi).
Pomocí Newtonovy metody lze takový polynom najít: Pn(x)=f0+f01(x-x0)+f02(x-x0)(x-x1)+&hellip;+f0n(x-x0)..(x-x(n-1)); funkce f(i,j) (od i pro j prvků) se definuje rekurzivně:</p>
<pre><code>f(i,j) = (f(i,j-1) - f(i+1,j-1))/(x(i)-x(i+j))
</code></pre>
<p>idk dále &hellip;</p>
<hr>
<h1 id="řazení-na-mřížkách">Řazení na mřížkách</h1>
<h2 id="shearsort">ShearSort</h2>
<p>Mřížka s N=n^2 prvky se řadí pro i od 1 do 2 log n + 1 iteracích střídavě hadovitě v jedné dimenzi a normálně v druhé dimenzi.
Důkaz správnosti si lze rozmyslet přes řazení 0/1.
Logaritmus, protože se počet řádek s mixovanými 0/1 půlí v každé iteraci.
Výsledek je hadovitě seřazená mřížka.</p>
<p>Obecná složitost paralelního řadícího algoritmu: T(N,p)=O(N/p log(N/p)) + O(t(p) N/p), kde t(p) je počet compare and exchange řazení p čísel na p procesorech.
Aplikováno na ShearSort kde máme t(p)=(2 log n + 1) &hellip; idk</p>
<h2 id="dolní-mez-na-2d-hadí-řazení-str-117">Dolní mez na 2D hadí řazení (str. 117)</h2>
<p>Rozdělme mřížku M(n,n), potom libovolné datově necitlivé hadí řazení potřebuje alespoň max(2n-2,3n-2sqrt(n)-4) compare and exchange operací.</p>
<p>2n-2 je triviální mez, jinak se nemohl prvek dostat z levého horního rohu do pravého dolního.</p>
<p>druhé nerozumím</p>
<h2 id="simulace-cubebms-na-2d-mřížce-bitonic-merge-sort">Simulace CubeBMS na 2D mřížce (bitonic merge sort?)</h2>
<p>Peano curve &ndash; je vnoření hyperkostky do mřížky Mn=M(2^(n/2),2^(n/2)), s &ldquo;nízkou&rdquo; dilatací dj=2^(j/2).
Simulace BMS na mřížce bude trvat n(n+1)/2 komunikačních kroků přes vzdálenost di, kde i jde po sekvenci [0,1,0,2,1,0,3,2,1,&hellip;,n-1,n-2,&hellip;,0].
Mějme N=2^n, pak součet takové řady je sum(i od 0 do n) sum(j od 0 do i) dj &lt;= sum(i od 1 do n/2) 4 2^i &lt;= 4 2^(n/2+1) = 8 sqrt(N).
Řazení simulací BMS na mřížce tak bude trvat T(N,p)=O(N/p log(N/p)) + O(N/sqrt(p)), kde první část je za sekvenční řazení bloků a druhá za BMS v čase N/p za exchange * sqrt(N/(N/p)) za BMS.</p>
<h2 id="časově-a-cenově-optimální-řadící-algoritmus-na-mřížkách">Časově a cenově optimální řadící algoritmus na mřížkách</h2>
<p>Mějme p=N jader, pak budeme řadit na mřížce následovně:
Rozřežeme mřížku na N^(1/4) bloků o velikosti N^(3/4); blokům ve stejné řadě/sloupci říkejme v/h-slice.
Provedeme osm fází řazení, [+složitost v O]:</p>
<ul>
<li>
<ol>
<li>seřadíme bloky snake-like [N^(3/8) log(N)]</li>
</ol>
</li>
<li>
<ol start="2">
<li>permutujme sloupce tak, aby byly sloupce bloku uniformě rozdělené ve všech blocích [N^(1/2)]</li>
</ol>
</li>
<li>
<ol start="3">
<li>seřadíme bloky snake-like [dtto 1]</li>
</ol>
</li>
<li>
<ol start="4">
<li>seřadíme sloupce [N^(1/2) parallel bubble sort]</li>
</ol>
</li>
<li>
<ol start="5">
<li>seřaďme odd-even dvojice vertikálně sousedních bloků snake-like [dtto 1]</li>
</ol>
</li>
<li>
<ol start="6">
<li>seřaďme even-odd dvojice vertikálně sousedních bloků snake-like [dtto 1]</li>
</ol>
</li>
<li>
<ol start="7">
<li>seřaďme řádky v globálním snake-like směru [dtto 4]</li>
</ol>
</li>
<li>
<ol start="8">
<li>provedeme 2N^(3/8) kroků odd-even transpozice dle globálního snake-like pořadí [2N^(3/8)]</li>
</ol>
</li>
</ul>
<p>Toto seřadí celou mřížku snake-like v čase 3N^(1/2) + o(N^(1/2)).</p>
<p>Pozorujeme jak se vyvyjí stav 0/1 po každém kroku:</p>
<ul>
<li>
<ol>
<li>každý blok obsahuje max jednu špinavou řádku</li>
</ol>
</li>
<li>
<ol start="2">
<li>počet jedniček v blocích v h-slice se liší maximálně o N^(1/8)</li>
</ol>
</li>
<li>
<ol start="3">
<li>každý h-slice obsahuje maximálně 2 špinavé řádky</li>
</ol>
</li>
<li>
<ol start="4">
<li>každý v-slice má maximálně N^(1/8) špinavých řádek</li>
</ol>
</li>
<li>5+6) slije vertikálně bloky, je pouze jeden špinavý řádek na v-slice; bloky uvnitř h-slice se lyší max o N^(2/8), což je méně N^(3/8) a proto budou globálně max 2 špinavé řádky; počet jedniček se v těchto blocích může lyšit nejvýše o N^(2/8) * N^(1/8)</li>
<li>
<ol start="7">
<li>2 špinavé řádky jsou teď nad sebou a seřazeny, horní může mít max N^(3/8) jedniček a dolní N^(3/8) nul</li>
</ol>
</li>
<li>
<ol start="8">
<li>posledních 2N^(3/8) prvků je seřazeno</li>
</ol>
</li>
</ul>
<p>Díky dvoum řazení a jedné permutaci je čas T(N,N)=3N^(1/2)+o(N^(1/2)).</p>
<hr>
<h1 id="batcherův-even-odd-merge-sort">Batcherův Even-Odd merge sort</h1>
<p>Síť s hloubkou log^2 n, která není datově citlivá a řadí.
Trik je vytvořit část sítě, která slije dvě seřazené posloupnosti.
Důkaz správnosti pomocí 0/1 lemma &ndash; rozdělení na sudé a liché do skupin nahoru a dolu zaručuje, že se počet jedniček skupin liší maximálně o jedna.
Proto bude na poslední sadé komparátoru pouze jedna pozice, kde může být 0/1 špatně &hellip; ta očividně bude opravena komparátorem.</p>
<p>U části permutace a komparací máme</p>
<ul>
<li>Časová složitost Tm(2) = 1, Tm(2N) = Tm(N)+1; Tm(2N) = log N + 1 = log(2N)</li>
<li>Cenová složitost Cm(2N) = N Tm(2N) = N log(2N)</li>
</ul>
<p>U části dělení na poloviny máme</p>
<ul>
<li>Časová složitost Ts(2N) = Ts(N) + Tm(2N) = Ts(N) + log(2N) = O(log^2(N))</li>
<li>Cenová složitost Cs(2N) = 2 Cs(N) + Cm(2N) = 2Cs(N) + N log(2N) = O(N log^2(N))</li>
</ul>
<p>Tento algoritmus je ekvivalentní řazení na hyperkrychli po dimenzích.
Tedy řadíme postupně dimenze: 1; 2, 1; 3, 2, 1; &hellip;</p>
<h1 id="batcherův-even-even-merge-sort">Batcherův Even-Even merge sort</h1>
<p>Pak je i varianta Batcherova algo. které je trochu jednodušší, páč se nemění volba prvků u první vs druhé skupině.
Komparátory o druhé části ovšem nemusí být u prvního a posledního prvku, protože víme, že jsou určitě seřazeny správně</p>
<h1 id="cenově-optimální-řadící-algoritmus-na-erew-pram---coleův-merge-sort">Cenově optimální řadící algoritmus na EREW PRAM - Coleův merge sort</h1>
<p>Myšlenka je jednoduchá &ndash; použijme rekurzivně tento algoritmus pro seřazení první a druhé poloviny pole.
Potom použijeme část algoritmu znovu, pro slití sudých prvků, a pak si projdeme výsledek kde v O(N) zjistíme pozice všech prvků na lichých indexech.
Itercí bude log n, protože sléváme posloupnosti velikosti 2^i.
Čas na slití posloupnosti je T(2N)=T(N)+O(N), což je celkově O(N); díky dělení v rekurzi tak máme celkově Tc(2N)=2Tc(N)+O(N)=O(N log N).</p>
<p>Vzpomeňme si, že algoritmus sekvenčního slévání dvou seřazených posloupností udržuje pointer do obou polí, porovná prvky a menší z nich kopíruje do výsledného pole.</p>
<p>První pozorování je, že výsledné slité pole obsahuje nejvýše dva prvky s lichými indexy z původních polí za sebou.
Součet indexů těchto pointerů při zkopírování prvku je roven pozici prvku ve výsledném poli.
Také pozorujeme, že pokud je sudý prvek na pozici j v seřazeném poli sudých prvků, tak se ve výsledném poli nachází v rozmezí 2j až 2j+2 (protože před ním jsou nejvýše dva liché prvky.
Pozice pointerů před jeho zkopírováním by tak musela být velice blízko p (pozice v původním poli) a 2j-p.
Jediná otázka tedy zbývá &hellip; je prvek vyšší než lichý prvek z druhého pole na pozici 2j-p-1?
Pokud ano, tak je ve výsledku na pozici 2j, jinak je na pozici 2j-1.</p>
<p>Vyřešili jsme sudé prvky, nyní k těm na lichých pozicích.
Díky tomu, že jsme zjistili úplnou informaci o pozicích pointerů pro sudé prvky, tak víme jak asi mohly vypadat pointery i pro liché prvky.
Pokud nějaký pointer ukazuje na náš lichý prvek, tak musel být tento prvek vyšší, než nějaký sudý prvek.
Hledáme tak poslední výskyt pointeru na tento prvek, protože to je ta hranice, kdy přestal být vyšší než prvky z druhého pole, a začal být nižší.
Protože je to poslední hodnota, tak tento prvek byl vyšší, než jeho protivník, ale nižší než další sudý prvek.
Jediné co potřebujeme je ho tedy porovnat s lichým prvkem mezi a máme definitivní pozici pointerů při zpracování tohoto prvku na liché pozici &ndash; tedy jeho výslednou pozici.</p>
<h1 id="paralelní-sken-na-spojových-seznamech">Paralelní sken na spojových seznamech</h1>
<p>Mějme jednosměrný spojový seznam reprezentovaný v poli, kde je na indexu I index následníka.</p>
<h2 id="plně-paralelní-vytvoření-pole-předchůdců-na-erew">Plně paralelní vytvoření pole předchůdců na EREW</h2>
<pre tabindex="0"><code>pro i od 0 do n
    pokud s[i]=i potom P[S[i]]=i
</code></pre><h2 id="list-ranking-na-crew">List ranking na CREW</h2>
<p>Úkolem je najít vzdálenost elementu od konce spojového seznamu.
Lze použít pro rychlé přelití do pole.</p>
<p>Použijeme pointer jumping.
Řeší v paralelním čase log N, a řeší i sufixový součet.
Není cenově optimální C(n,n) = O(n log n).
Může být pracovně optimální pokud jádra přeskakují pouze nehotové elementy &ndash; ve chvíli kdy dojdou na vyřešený element, tak ukončí výpočet.
I takováto varianta není cenově optimální, protože polovina elementů dělá pořád log n skoků.</p>
<p>Pokud chceme cenově optimální algo. můžeme vzít n&rsquo;=n/log n jader a komprimovat spojový seznam na n&rsquo; prvků.
Provedení předchozího algoritmu potom bude cenově optimální C(n&rsquo;,n)=O(n), ovšem je potřeba rychle provést i kompresi a dekompresi &ldquo;schovaných&rdquo; elementů.</p>
<p>Prvky, které přeskočíme, budeme vybírat pomocí pseudonáhodného obarvení vrcholů.
Zjevně, pokud obarvíme linked-list K barvami a vybereme lokální minima obarvení, tak jsme vybrali alespoň N/K-1 vrcholů.
Pokud chceme obarvovat části linked listu nezávisle, tak budeme potřebovat alespoň 3 barvy; zároveň to i ve 3 barvách zvládneme.
Pokud nad listem provedeme log log n (lln) 3-obarvení a odebrání maxim, dostaneme list velikosti n (3/4)^(log log n) = n/log n.
Na tomto listu provedeme PPS v O(n) a list znovu nafoukneme a nastavíme rank na rank následníka + 1.</p>
<p>Nejdéle trvá konverze O(log n.loglog n). Cenově tedy algo. vyjde O(n loglog n).
Pracovně ale algoritmus vyjde O(n), protože pointer jumping se dělá n/log n jádry na vstup velikosti n/log n v O(n) a redukce se udělá v O(n log*n).</p>
<h1 id="paralelní-souvislé-komponenty-na-crcw">Paralelní souvislé komponenty na CRCW</h1>
<p>Paralelní postup bude bottom up &ndash; přes hrany budeme užívat union-find algoritmus, každá komponenta tak bude na konci mít jednoho reprezentanta v kořenu stromu všech vrcholů komponenty.
Problém může nastat, pokud bychom v jednom kroku nastavili rodiče vrcholům vzájemně, tedy P[i]=j, P[j]=i, což by vytvořilo cyklus.</p>
<p>Řešení problému paralelizace spočívá v porovnání ID vrcholů, které chceme spojit, a spojení pouze pokud ID[i]&lt;ID[j].</p>
<p>Z důvodu rozumné analýzy se na začátku provede:</p>
<pre tabindex="0"><code>pro každý vrchol i a prvního souseda j
    pokud i&gt;j, tak union(i,j)
    pokud nebyl vrchol i unifikovaný, proveď union(i,j)
</code></pre><p>Oba kroky jsou jednosměrné a nevytvoří cykly.
První krok je jednosměrný díky srovnání a nedělá cykly, protože nemůže i&lt;j,j&lt;k a k&lt;i.
Druhý krok je také v pořádku, protože nelze aby j byl taky neunifikovaný, jinak by se spojil v prvním kroku.</p>
<p>Důkaz rychlosti se udělá přes sumu hloubky všech stromů.
Díky inicializaci je hloubka maximálně n-1 (cesta).
Nyní provedeme následující:</p>
<pre tabindex="0"><code>cyklus
    identifikuj hvězdy: if P[P[i]]!=P[i] pak P[P[i]] není hvězda
    pro všechny hrany ij pokud je i kořen
        pokud P[i]&gt;P[j] union(i,j)
        pokud P[i]!=P[j] union(i,j)
    pro všechny vrcholy provedeme pointer jumping
opakuj cyklus, dokud pointer jumping něco změnil
</code></pre><p>Důkaz správnosti: po inicializaci máme les; cyklus spojí dvě hvězdy pod sebe a potom může připojit hvězdu pod nehvězdu (ne naopak!), což nevytvoří cyklus; pointer jumping netvoří cykly.</p>
<p>Důkaz rychlosti: po inicializaci je hloubka součtu stromů nejvýše n-1-(počet isolovaných vrcholů), tato hodnota se žádnou operací nemůže zvýšit; pointer jumping sníží hloubku (lichých) stromů na (h+1)/2 &lt; 2h/3; součet hloubek stromů je v i-té iteraci (2h/3)^i</p>
<h1 id="paralelní-kontrakce-stromu">Paralelní kontrakce stromu</h1>
<p>Na strom můžeme použít operace Rake (odebrání listů) a Komprese (zkrácení cest pomocí pointer jumping).</p>
<pre tabindex="0"><code>dokud je počet neoznačených synů roota nenulový
    pro všechny nekořenové vrcholy v z V(T)
        pokud je počet neoznačených synů v roven
            0: rake v
            1: komprimuj v
rake root
</code></pre><p>Potíž je, že tohle není pracovně optimální W(n,p)=n log(n) (počítají se zbytečné části stromu).</p>
<p>Shunt operace je Rake + Komprese sourozence.
Tuto operaci není možné použít na oba sourozence zároveň, nebo na vrchol a jeho strýce.
Pokud listy očíslujeme, tak zpracováním pouze těch lichých levých listů nemůže dojít k nevalidnímu zpracování.
Proto provedeme Shunt nejdříve na všech lichých listech vlevo, potom vpravo, ostatní čísla vydělíme 2mi a opakujeme.</p>
<p>Očíslování listů provedeme přes eulerovský tah (lze ryhle přes LL dle pravidla pravé ruky) kde označíme hranu do listu váhou 1 a zbytek 0, tak bude mít po suffixové sumě hrana z vrcholu do rodiče váhu počtu listů v podstromě.</p>
<pre tabindex="0"><code>Shunt(v):
    Rake(v); active[v]=0; active[P[v]]=0;
    Compress(sibling[v]); P[sibling[v]]=P[P[v]];

CompressTree(T):
    spočti počet listů podstromu každého vrcholu T
    pro všechny vrcholy v z V(T)
        aktivní[v]=je v list?
    opakuj log n krát
        pro všechny aktivní nekořenové vrcholy v z V(T)
            pokud je v lichý v očíslování a P[v] není root
                Shunt(v)
            jinak
                očíslování[v]/=2
    Rake(root)
</code></pre><p>Mějme p=n/log n, přidělíme každému jádru log n/2 listů.
Shunt zničí alespoň polovinu listů, takže provedeme nejvýše log n/2+log n/4+&hellip;+log n/(2^log log n) + 1 + &hellip; + 1 &lt;= 2 log n = O(log n) kroků.</p>

        </div>
    </div>
</div>

<div class="footer">
    <ul class="pad-content">

        <li>
            © Václav Blažej
            
                2018
            
        </li>
        

        

        
    </ul>
    <ul title="Last update of the website" class="pull-right pad">9. September 2025</ul>
</div>

<script type="text/javascript">
    $("#toggle-btn").click(function(){
        $("#toggle-content").toggle();
        if($(this).html() === "☰") {
            $(this).html("X")
        } else {
            $(this).html("☰")
        }
    });
    $(window).resize(function(){
        if(window.innerWidth > 768) {
            $(".desktop").removeAttr("style");
        }
    });
</script>
</body>
</html>

