<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stringology on Homepage of Vašek</title>
    <link>https://vaclavblazej.github.io/tags/stringology/</link>
    <description>Recent content in Stringology on Homepage of Vašek</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>© Václav Blažej</copyright>
    <lastBuildDate>Sat, 20 May 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://vaclavblazej.github.io/tags/stringology/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>On the smallest synchronizing terms of finite tree automata</title>
      <link>https://vaclavblazej.github.io/pub/2023/synchronization/</link>
      <pubDate>Sat, 20 May 2023 00:00:00 +0000</pubDate>
      <guid>https://vaclavblazej.github.io/pub/2023/synchronization/</guid>
      <description>&lt;p&gt;It is well-known that the shortest synchronizing words for any automata lies between $n^2$ and roughly $n^3$.&#xA;We focused on the same question but for tree automata, i.e., what are the &amp;ldquo;smallest&amp;rdquo; terms which sychronize a tree automaton?&lt;/p&gt;&#xA;&lt;p&gt;It became clear that classical notion of sychronization does not 1-to-1 correspond to this new setting, so we define &amp;ldquo;weak&amp;rdquo; and &amp;ldquo;strong&amp;rdquo; synchronization and show bounds for both.&#xA;The weak sychronization is more string-like &amp;ndash; the interesting part of simpmlest synchronization terms boil down to a single path which is basically a string.&#xA;Surprisingly, the classical lower-bounds for strings stop working in this setting as it is not at all obvious that the sychronizing term cannot do something clever with the two subtrees to sychronize swiftly &amp;ndash; this takes mental effort to persuade yourself that is it not trivial.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Simple Streaming Bit-parallel Algorithm for Swap Pattern Matching</title>
      <link>https://vaclavblazej.github.io/pub/2015/gsm/</link>
      <pubDate>Fri, 06 Nov 2015 00:00:00 +0000</pubDate>
      <guid>https://vaclavblazej.github.io/pub/2015/gsm/</guid>
      <description>&lt;p&gt;In this paper we present a streaming algorithm for Pattern Matching with Swaps (Swap Matching).&lt;/p&gt;&#xA;&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;&#xA;&lt;p&gt;The pattern matching problem with swaps is to find all occurrences of a pattern in a text while allowing the pattern to swap adjacent symbols.&#xA;The goal is to design fast matching algorithm that takes advantage of the bit parallelism of bitwise machine instructions&#xA;and has only streaming access to the input.&#xA;We introduce a new approach to solve this problem based on the graph theoretic model and compare its performance to previously known algorithms.&#xA;We also show that an approach using deterministic finite automata cannot achieve similarly efficient algorithms.&#xA;Furthermore, we describe a fatal flaw in some of the previously published algorithms based on the same model.&#xA;Finally, we provide experimental evaluation of our algorithm on real-world data.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
